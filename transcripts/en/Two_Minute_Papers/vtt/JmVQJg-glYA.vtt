WEBVTT

1
00:00:00.090 --> 00:00:04.200
<v 0>Dear fellow scholars. This is two minute papers with Dr. [inaudible].</v>

2
00:00:04.620 --> 00:00:05.610
What do you see here is that.

3
00:00:06.050 --> 00:00:07.100
<v 1>Band of vector images.</v>

4
00:00:07.460 --> 00:00:11.300
The vector images are not like most images that you see on the internet.

5
00:00:11.570 --> 00:00:16.520
Those are Esther images, and those are like photos and are made of pixels.

6
00:00:16.760 --> 00:00:20.930
While vector images are not made of pixels, they are made of shapes.

7
00:00:21.260 --> 00:00:23.570
These vector images have lots of advantages.

8
00:00:23.810 --> 00:00:28.310
They have really small fire sizes can be zoomed into as much as we

9
00:00:28.311 --> 00:00:30.980
desire and things don't get pixelated.

10
00:00:31.430 --> 00:00:35.990
And Hans vector images are really well suited for logos, user interface,

11
00:00:35.991 --> 00:00:39.320
icons, and more. Now, if we wish to,

12
00:00:39.500 --> 00:00:42.980
we can convert vector images into raster images.

13
00:00:43.190 --> 00:00:46.790
So the shapes will become pixels. This is easy,

14
00:00:47.120 --> 00:00:50.060
but here's the problem. If we do it once,

15
00:00:50.150 --> 00:00:53.060
there is no going back or at least not easily.

16
00:00:53.510 --> 00:00:56.990
This method promises to make this conversion a two-way street.

17
00:00:57.200 --> 00:01:00.650
So we can take a raster image, a photo, if you will,

18
00:01:01.010 --> 00:01:04.940
and work with it as if it were a vector image. Now,

19
00:01:05.060 --> 00:01:09.320
what does that mean? Oh boy, a lot of goodies, for instance,

20
00:01:09.321 --> 00:01:12.140
we can perform sculpting or in other words,

21
00:01:12.320 --> 00:01:15.650
manipulating shapes without touching any pixels,

22
00:01:16.340 --> 00:01:20.210
we can work with the shapes here is that much easier,

23
00:01:20.480 --> 00:01:23.690
or my favorite perform painterly rendering.

24
00:01:24.290 --> 00:01:27.890
Now what you see here is not the new algorithm performing this.

25
00:01:28.220 --> 00:01:31.700
And this is a genetic algorithm. I wrote a few years ago.

26
00:01:31.880 --> 00:01:33.320
That takes a target image,

27
00:01:33.470 --> 00:01:38.300
which is the MonaLisa here takes a bunch of randomly colored triangles

28
00:01:38.600 --> 00:01:43.190
and starts reorganizing them to get as close to the target image as

29
00:01:43.191 --> 00:01:44.024
possible.

30
00:01:44.360 --> 00:01:48.260
And the source code and a video explaining how it works is available in the

31
00:01:48.261 --> 00:01:49.100
video description.

32
00:01:49.670 --> 00:01:53.960
And now let's see how this new method performs on a similar task.

33
00:01:54.290 --> 00:01:58.520
It can start with a large number of different shapes and just look at how

34
00:01:58.521 --> 00:02:02.960
beautifully these shapes evolve and start converging to the target image,

35
00:02:03.800 --> 00:02:06.350
loving it, but that's not all.

36
00:02:06.650 --> 00:02:09.830
It also has a nice solution to an old, bad,

37
00:02:09.890 --> 00:02:14.420
challenging problem in computer graphics that is referred to as seam carving.

38
00:02:15.140 --> 00:02:19.250
If you ask me, I like to call it image squishing, why?

39
00:02:20.570 --> 00:02:21.770
Well, look here,

40
00:02:22.130 --> 00:02:26.600
this gives us an easy way of intelligently squishing an image into different

41
00:02:26.660 --> 00:02:29.750
aspect ratios. So good.

42
00:02:30.560 --> 00:02:33.860
So can we measure how well it does what it does?

43
00:02:34.370 --> 00:02:38.660
How does it compare to add obese state of the art method when vectorizing

44
00:02:38.690 --> 00:02:42.530
affordable? Well, it can not only do more,

45
00:02:42.800 --> 00:02:45.050
but it also does it better.

46
00:02:45.470 --> 00:02:49.010
The new method is significantly closer to the target image here.

47
00:02:49.220 --> 00:02:52.400
No question about it. And now comes the best part.

48
00:02:52.880 --> 00:02:56.690
It not only provides higher quality results than the previous methods,

49
00:02:57.020 --> 00:03:01.870
but it only takes approximately a second to perform all this.

50
00:03:02.470 --> 00:03:06.820
Wow. So there you go. Finally, with this technique,

51
00:03:06.880 --> 00:03:10.540
we can edit pixels as if they weren't pixels at all.

52
00:03:11.110 --> 00:03:15.910
It feels like we are living in a science fiction world. What a time to be alive.

53
00:03:16.450 --> 00:03:19.780
This episode has been supported by Lambda GPU cloud.

54
00:03:19.960 --> 00:03:23.350
If you're looking for inexpensive cloud GPU's for AI,

55
00:03:23.530 --> 00:03:25.660
check out Lambda GPU cloud,

56
00:03:26.080 --> 00:03:29.740
they recently launched Quadro RTX 6,000 RTX,

57
00:03:29.770 --> 00:03:34.480
8,000 and V 100 instances and hold onto your papers

58
00:03:34.570 --> 00:03:39.190
because Lambda GPU cloud can cost less than half of AWS

59
00:03:39.370 --> 00:03:40.203
and Azure.

60
00:03:40.330 --> 00:03:45.280
Plus they are the only cloud service with 48 gigabyte RDX, eight thousands.

61
00:03:45.970 --> 00:03:49.210
Join researchers at organizations like Apple, MIT,

62
00:03:49.300 --> 00:03:53.710
and Caltech in using Lambda cloud instances, workstations or servers,

63
00:03:53.920 --> 00:03:58.660
make sure to go to Lambda labs.com/papers to sign up for one of their

64
00:03:58.661 --> 00:04:00.490
amazing GPU instances today.

65
00:04:00.760 --> 00:04:05.260
Our thanks to Lambda for the longstanding support and for helping us make better

66
00:04:05.261 --> 00:04:08.290
videos for you. Thanks for watching and for your generous support.

67
00:04:08.470 --> 00:04:10.240
And I'll see you next time.

